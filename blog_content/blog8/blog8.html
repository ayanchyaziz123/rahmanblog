<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climbing Stairs - LeetCode Problem</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9fafb;
            color: #1f2937;
        }
        h1, h2 {
            color: #1f2937;
        }
        .code-container {
            background: #2e3440;
            color: #d8dee9;
            padding: 1em;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .code-container pre {
            margin: 0;
            overflow-x: auto;
        }
        .image-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>

<h1 style="font-size: 28px; color: #1f2937; margin-bottom: 20px;">Climbing Stairs - LeetCode Problem</h1>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Problem Statement</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    You are climbing a staircase. It takes <strong>n</strong> steps to reach the top. Each time you can either climb 1 or 2 steps. 
    In how many distinct ways can you climb to the top?
</p>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Example</h2>
<h3 style="font-size: 20px; margin-bottom: 10px;">Example 1:</h3>
<p style="font-size: 18px; margin-bottom: 15px;">
    <strong>Input:</strong> n = 2<br>
    <strong>Output:</strong> 2<br>
    <strong>Explanation:</strong> There are two ways to climb to the top:<br>
    1. 1 step + 1 step<br>
    2. 2 steps
</p>

<h3 style="font-size: 20px; margin-bottom: 10px;">Example 2:</h3>
<p style="font-size: 18px; margin-bottom: 15px;">
    <strong>Input:</strong> n = 3<br>
    <strong>Output:</strong> 3<br>
    <strong>Explanation:</strong> There are three ways to climb to the top:<br>
    1. 1 step + 1 step + 1 step<br>
    2. 1 step + 2 steps<br>
    3. 2 steps + 1 step
</p>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Recursion Tree</h2>
<div class="image-container">
    <img src="/blog_content/blog8/blog8_image.png" alt="Recursion Tree for Climbing Stairs">
</div>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Dynamic Programming Approach</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    This problem can be efficiently solved using dynamic programming. The key insight is to realize that the number of ways 
    to reach step <strong>n</strong> is the sum of the ways to reach steps <strong>n-1</strong> and <strong>n-2</strong>.
</p>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Python Solution</h2>
<div class="code-container">
    <pre><code>class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [-1] * 46  # Array to store results of subproblems

        def solve(n):
            if dp[n] != -1:  # Return already computed value
                return dp[n]
            if n < 0:
                return 0  # No way to climb negative steps
            if n == 0:
                return 1  # One way to stay at the ground level
            dp[n] = solve(n-1) + solve(n-2)  # Recursive call for n-1 and n-2
            return dp[n]

        return solve(n)

# Example usage
solution = Solution()
print(solution.climbStairs(5))  # Output: 8
    </code></pre>
</div>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">C++ Solution</h2>
<div class="code-container">
    <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, -1); // Array to store results of subproblems

        return solve(n, dp);
    }

private:
    int solve(int n, vector<int>& dp) {
        if (dp[n] != -1) return dp[n]; // Return already computed value
        if (n < 0) return 0; // No way to climb negative steps
        if (n == 0) return 1; // One way to stay at the ground level
        dp[n] = solve(n - 1, dp) + solve(n - 2, dp); // Recursive call for n-1 and n-2
        return dp[n];
    }
};

// Example usage
int main() {
    Solution solution;
    cout &lt;&lt; solution.climbStairs(5); // Output: 8
    return 0;
}
    </code></pre>
</div>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Conclusion</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    The "Climbing Stairs" problem is an excellent example of how dynamic programming can optimize recursive solutions. 
    By storing intermediate results, we avoid redundant calculations, significantly improving performance.
</p>

</body>
</html>
