<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LeetCode Subset Problem Solution</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      color: #1f2937;
    }

    h1, h2 {
      color: #1f2937;
    }

    ul {
      margin-left: 20px;
    }

    .code-container {
      background: #2e3440;
      color: #d8dee9;
      padding: 1em;
      border-radius: 5px;
      margin-bottom: 20px;
    }

    .code-container pre {
      margin: 0;
      overflow-x: auto;
    }

    .recursion-image {
      max-width: 100%;
      height: auto;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>

<h1 style="font-size: 28px; color: #1f2937; margin-bottom: 20px;">LeetCode Subset Problem: Efficient Recursion Solution</h1>

<p style="font-size: 18px; margin-bottom: 15px;">
    In this blog post, we will walk through solving the LeetCode subset problem using recursion and the "include/exclude" method. This approach provides a clear, efficient way to generate all possible subsets of an array.
</p>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Problem Statement</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    Given a list of distinct integers, return all possible subsets (the power set). The solution should contain no duplicate subsets, and the order of the subsets does not matter.
</p>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Approach: Recursion (Include/Exclude)</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    We can use recursion to solve this problem. At each recursive step, we make a decision to either <strong>include</strong> or <strong>exclude</strong> the current element. This decision-making process can be visualized using a recursion tree, where each node represents a recursive call.
</p>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Code Implementation</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    Below is the Python code for solving the subset problem using the "include/exclude" recursion method. The helper function `solve` is called recursively to explore all possible subsets of the input array <code>nums</code>.
</p>

<div class="code-container">
  <h3 style="font-size: 20px; margin-bottom: 10px;">Python Code</h3>
  <pre><code>from typing import List

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        
        # Recursive function to explore subsets
        def solve(ind, arr):
            # If we have processed all elements, add the subset to the result
            if ind == len(nums):
                res.append(arr.copy())
                return
            
            # Include the current element
            arr.append(nums[ind])
            solve(ind + 1, arr)
            
            # Exclude the current element (backtrack)
            arr.pop()
            solve(ind + 1, arr)
        
        solve(0, [])
        return res

# Example usage
nums = [1, 2, 3]
solution = Solution()
print(solution.subsets(nums))
  </code></pre>
</div>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Explanation</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    In the above code, the function <code>solve</code> is responsible for generating subsets. Here's a step-by-step breakdown of how the recursion works:
</p>

<ul style="font-size: 18px; margin-bottom: 20px;">
    <li>We start by calling <code>solve(0, [])</code>, where <code>0</code> is the current index in the array, and <code>[]</code> is the subset we are currently building.</li>
    <li>At each step, we make two choices: either include <code>nums[ind]</code> in the subset or exclude it.</li>
    <li>When <code>ind</code> reaches the length of the array, we add the current subset to the result list <code>res</code>.</li>
    <li>We use the <code>arr.pop()</code> operation to backtrack after exploring a branch where the element is included, allowing us to explore the branch where it is excluded.</li>
</ul>

<h2 style="font-size: 24px; color: #1f2937; margin-bottom: 15px;">Time Complexity</h2>
<p style="font-size: 18px; margin-bottom: 15px;">
    The time complexity of this approach is <strong>O(2<sup>n</sup>)</strong>, where <strong>n</strong> is the number of elements in the input array. This is because for every element, we have two choices—either include or exclude it—leading to <strong>2<sup>n</sup></strong> subsets.
</p>

<p style="font-size: 18px; margin-bottom: 15px;">
    This recursive solution is not only simple and elegant but also efficient for generating all subsets of a small array.
</p>

</body>
</html>
